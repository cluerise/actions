name: Create release PR

on:
  workflow_dispatch:
  workflow_call:
    inputs:
      app-id:
        type: string
        description: GitHub app ID
      manager:
        type: string
        description: Package manager (pnpm, npm, or yarn)
      release-command:
        type: string
        description: Release command to run instead of releasing using targets
      release-target:
        type: string
        description: Release target name
      release-targets:
        type: string
        description: JSON object defining release targets and their packages
      npm-config-userconfig:
        type: string
        description: NPM configuration file path
      __external-call:
        type: boolean
        description: Do not use this input, it is an internal value to identify the workflow_call event
        default: true
    secrets:
      token:
        description: GitHub access token
        required: false
      app-private-key:
        description: GitHub app private key
        required: false
      npm-auth-token:
        description: NPM authentication token for private packages
        required: false

env:
  INPUT_APP_ID: ${{ inputs.app-id || vars.CLUERISE_PUBLIC_BOT_APP_ID }}
  INPUT_MANAGER: ${{ inputs.manager }}
  INPUT_RELEASE_COMMAND: ${{ inputs.release-command }}
  INPUT_RELEASE_TARGET: ${{ inputs.release-target }}
  INPUT_RELEASE_TARGETS: ${{ inputs.release-targets || '{}' }}
  INPUT_EXTERNAL_CALL: ${{ inputs.__external-call || false }}
  SECRET_TOKEN: ${{ secrets.token }}
  SECRET_APP_PRIVATE_KEY: ${{ secrets.app-private-key || secrets.CLUERISE_PUBLIC_BOT_APP_PRIVATE_KEY }}
  NPM_AUTH_TOKEN: ${{ secrets.npm-auth-token }}
  NPM_CONFIG_USERCONFIG: ${{ inputs.npm-config-userconfig }}

permissions:
  contents: read
  pull-requests: write

jobs:
  create-release-pr:
    name: Create release PR
    runs-on: ubuntu-latest

    steps:
      - name: Set release command
        if: env.INPUT_RELEASE_COMMAND == '' && env.INPUT_RELEASE_TARGET == '' && env.INPUT_RELEASE_TARGETS == '{}'
        run: echo "INPUT_RELEASE_COMMAND=pnpm run release create" >> $GITHUB_ENV

      - name: Check required secrets
        if: env.SECRET_TOKEN == '' && (env.INPUT_APP_ID == '' || env.SECRET_APP_PRIVATE_KEY == '')
        run: exit 1

      - name: Get bot token (main)
        id: get-bot-token-main
        if: env.INPUT_EXTERNAL_CALL == 'false' && env.SECRET_TOKEN == ''
        uses: cluerise/actions/get-github-app-token@main
        with:
          app-id: ${{ env.INPUT_APP_ID }}
          app-private-key: ${{ env.SECRET_APP_PRIVATE_KEY }}

      - name: Get bot token (version)
        id: get-bot-token-version
        if: env.INPUT_EXTERNAL_CALL == 'true' && env.SECRET_TOKEN == ''
        uses: cluerise/actions/get-github-app-token@v6.0.5
        with:
          app-id: ${{ env.INPUT_APP_ID }}
          app-private-key: ${{ env.SECRET_APP_PRIVATE_KEY }}

      - name: Set bot token
        run: echo "BOT_TOKEN=${{ steps.get-bot-token-main.outputs.token || steps.get-bot-token-version.outputs.token }}" >> $GITHUB_ENV

      - name: Install (main)
        if: env.INPUT_EXTERNAL_CALL == 'false'
        uses: cluerise/actions/install@main
        with:
          fetch-depth: 0

      - name: Install (version)
        if: env.INPUT_EXTERNAL_CALL == 'true'
        uses: cluerise/actions/install@v6.0.5
        with:
          manager: ${{ env.INPUT_MANAGER }}
          fetch-depth: 0

      - name: Run the release command
        id: release-command
        if: env.INPUT_RELEASE_COMMAND != ''
        run: ${{ env.INPUT_RELEASE_COMMAND }}

      - name: Set Git user for temporary commits
        if: env.INPUT_RELEASE_COMMAND == ''
        run: |
          git config user.name "Cluerise Bot"
          git config user.email "bot@cluerise.com"

      - name: Run the release command for targets
        id: release-targets
        if: env.INPUT_RELEASE_COMMAND == ''
        uses: actions/github-script@v7.0.1
        with:
          script: |
            const getPackageScope = async (packageName) => {
              const prodCommand = `pnpm ls -r ${packageName} --json | grep dependencies | wc -l`;
              const devCommand = `pnpm ls -r ${packageName} --json | grep devDependencies | wc -l`;

              let prodCommandOutput = '';
              let devCommandOutput = '';

              await exec.exec('/bin/bash', ['-c', prodCommand], {
                listeners: {
                  stdout: (data) => {
                    prodCommandOutput += data.toString();
                  }
                }
              });

              await exec.exec('/bin/bash', ['-c', devCommand], {
                listeners: {
                  stdout: (data) => {
                    devCommandOutput += data.toString();
                  }
                }
              });

              const prodDependencyType = parseInt(prodCommandOutput.trim(), 10) > 0;
              const devDependencyType = parseInt(devCommandOutput.trim(), 10) > 0;

              return prodDependencyType ? 'prod' : devDependencyType ? 'dev' : null;
            };

            const getReleaseInfo = async (packageName) => {
              let releaseInfoData = '';
              await exec.exec('pnpm', ['run', '--filter', packageName, '--silent', 'release', 'info'], {
                listeners: {
                  stdout: (data) => {
                    releaseInfoData += data.toString();
                  }
                }
              });

              return JSON.parse(releaseInfoData);
            };

            // -----------------------------------------------------------------

            const targetName = core.getInput('release-target', { required: true });
            const targets = JSON.parse(core.getInput('release-targets', { required: true }));

            const packageNames = targets[targetName];
            if (!packageNames) {
              core.setFailed(`Release target "${targetName}" not found in targets: ${JSON.stringify(Object.keys(targets))}`);
              return;
            }

            for (const packageName of packageNames) {
              const oldReleaseInfo = await getReleaseInfo(packageName);
              await exec.exec('pnpm', ['run', '--filter', packageName, 'release', 'create']);
              const newReleaseInfo = await getReleaseInfo(packageName);

              if (oldReleaseInfo.version !== newReleaseInfo.version) {
                const scope = await getPackageScope(packageName);
                const scopeName = scope ? `(${scope})` : '';

                await exec.exec('git', ['stash']);
                await exec.exec('find', ['.', '-type', 'f', '-name', 'package.json', '!', '-path', '*/node_modules/*', '-exec', 'sed', '-i', `s|"${packageName}": "workspace:\\*"|"${packageName}": "${newReleaseInfo.version}"|g`, '{}', '+']);
                await exec.exec('git', ['commit', '--allow-empty', '--no-verify', '-a', '-m', `deps${scopeName}: Update ${packageName} ${oldReleaseInfo.version} to ${newReleaseInfo.version}`]);
                await exec.exec('git', ['stash', 'pop']);
              }
            }

          release-target: ${{ env.INPUT_RELEASE_TARGET }}
          release-targets: ${{ env.INPUT_RELEASE_TARGETS }}

      - name: Remove temporary commits
        if: env.INPUT_RELEASE_COMMAND == ''
        run: |
          git stash
          git reset --hard @{upstream}
          git stash pop || true

      - name: Release info
        id: release-info
        uses: actions/github-script@v7.0.1
        with:
          script: |
            const commandReleasesInput = JSON.parse(core.getInput('command-releases'));
            const targetReleasesInput = JSON.parse(core.getInput('target-releases'));

            const releasesInput = typeof commandReleasesInput === 'object' && Object.keys(commandReleasesInput).length > 0
              ? commandReleasesInput
              : targetReleasesInput;

            const defaultRelease = JSON.parse(releasesInput.release);

            const releases = Object.entries(releasesInput)
              .filter(([key]) => key.startsWith('release.'))
              .map(([_key, value]) => JSON.parse(value))
              .toSorted((releaseA, releaseB) => releaseA.name.localeCompare(releaseB.name));

            const title = releases.length === 1
              ? `release: Release \`${defaultRelease.tag}\``
              : `release: Release of ${releases.length} packages`;

            const tableRows = [
              ['Name', 'Type', 'Versions', 'Tag'],
              ['---', '---', '---', '---'],
              ...releases.map(release => [
                `\`${release.name}\``,
                release.type,
                `\`${release.versions.from}\` to \`${release.versions.to}\``,
                `\`${release.tag}\``
              ])
            ];

            const table = tableRows.map(row => `| ${row.join(' | ')} |`).join('\n');

            core.setOutput('title', title);
            core.setOutput('body', table);

          command-releases: ${{ toJSON(steps.release-command.outputs) }}
          target-releases: ${{ toJSON(steps.release-targets.outputs) }}

      - name: Create a pull request with the release (main)
        if: env.INPUT_EXTERNAL_CALL == 'false'
        uses: branoholy/update-files-action@main
        with:
          token: ${{ env.BOT_TOKEN }}
          branch.name: release
          branch.recreate: true
          commit.paths: |
            **/package.json
            pnpm-lock.yaml
            package-lock.json
            yarn.lock
            **/CHANGELOG.md
            .github/workflows/*.yaml
          commit.message: ${{ steps.release-info.outputs.title }}
          commit.token: ${{ env.BOT_TOKEN }}
          pull-request.body: ${{ steps.release-info.outputs.body }}
          pull-request.labels: 'type: release'

      - name: Create a pull request with the release (version)
        if: env.INPUT_EXTERNAL_CALL == 'true'
        uses: branoholy/update-files-action@main
        with:
          token: ${{ env.SECRET_TOKEN || env.BOT_TOKEN }}
          branch.name: release
          branch.recreate: true
          commit.paths: |
            **/package.json
            pnpm-lock.yaml
            package-lock.json
            yarn.lock
            **/CHANGELOG.md
            **/*.pbxproj
          commit.message: ${{ steps.release-info.outputs.title }}
          commit.token: ${{ env.BOT_TOKEN || secrets.GITHUB_TOKEN }}
          pull-request.body: ${{ steps.release-info.outputs.body }}
          pull-request.labels: 'type: release'
