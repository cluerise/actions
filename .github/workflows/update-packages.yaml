name: Update packages

on:
  schedule:
    - cron: '0 11 * * 0' # Every Sunday at 11:00 UTC
  workflow_dispatch:
    inputs:
      update-strategy:
        type: choice
        description: Update strategy
        options:
          - Single PR
          - Multiple PRs
        default: Single PR
      max-pull-requests:
        type: number
        description: Max pull requests
  workflow_call:
    inputs:
      app-id:
        type: string
        description: GitHub app ID
      update-strategy:
        type: string
        description: Update strategy (Single PR or Multiple PRs)
      max-pull-requests:
        type: number
        description: Max pull requests
      package-groups:
        type: string
        description: JSON object defining package groups for updates
      ignored-packages:
        type: string
        description: JSON array of package names to ignore
      npm-config-userconfig:
        type: string
        description: NPM configuration file path
      __external-call:
        type: boolean
        description: Do not use this input, it is an internal value to identify the workflow_call event
        default: true
    secrets:
      token:
        description: GitHub access token
        required: false
      app-private-key:
        description: GitHub app private key
        required: false
      npm-auth-token:
        description: NPM authentication token for private packages
        required: false

env:
  INPUT_APP_ID: ${{ inputs.app-id || vars.CLUERISE_PUBLIC_BOT_APP_ID }}
  INPUT_UPDATE_STRATEGY: ${{ inputs.update-strategy || 'Single PR' }}
  INPUT_MAX_PULL_REQUESTS: ${{ fromJSON(inputs.max-pull-requests || '3') }}
  INPUT_PACKAGE_GROUPS: ${{ inputs.package-groups || '{}' }}
  INPUT_IGNORED_PACKAGES: ${{ inputs.ignored-packages || '[]' }}
  INPUT_EXTERNAL_CALL: ${{ inputs.__external-call || false }}
  SECRET_TOKEN: ${{ secrets.token }}
  SECRET_APP_PRIVATE_KEY: ${{ secrets.app-private-key || secrets.CLUERISE_PUBLIC_BOT_APP_PRIVATE_KEY }}
  NPM_AUTH_TOKEN: ${{ secrets.npm-auth-token }}
  NPM_CONFIG_USERCONFIG: ${{ inputs.npm-config-userconfig }}

permissions:
  contents: read
  pull-requests: write

jobs:
  prepare-updates:
    name: Prepare updates
    runs-on: ubuntu-latest
    outputs:
      updates: ${{ steps.prepare-updates.outputs.updates }}

    steps:
      - name: Check required secrets
        if: env.SECRET_TOKEN == '' && (env.INPUT_APP_ID == '' || env.SECRET_APP_PRIVATE_KEY == '')
        run: exit 1

      - name: Install (main)
        if: env.INPUT_EXTERNAL_CALL == 'false'
        uses: cluerise/actions/install@main

      - name: Install (version)
        if: env.INPUT_EXTERNAL_CALL == 'true'
        uses: cluerise/actions/install@v7.0.4

      - name: Get outdated packages
        id: get-outdated-packages
        run: |
          {
            echo "outdated-prod-packages<<EOF_OUTDATED_PROD_PACKAGES"
            pnpm outdated --recursive --json --prod || true
            echo "EOF_OUTDATED_PROD_PACKAGES"

            echo "outdated-dev-packages<<EOF_OUTDATED_DEV_PACKAGES"
            pnpm outdated --recursive --json --dev || true
            echo "EOF_OUTDATED_DEV_PACKAGES"
          } >> $GITHUB_OUTPUT;

      - name: Prepare updates
        id: prepare-updates
        uses: actions/github-script@v8.0.0
        with:
          script: |
            const getCurrentDateString = () => {
              const dateTime = new Date();
              const [date, _time] = dateTime.toISOString().split('T');

              return date;
            };

            const preparePackages = (prodPackages, devPackages, ignoredPackages) => {
              const packages = {};

              const packageNames = new Set([
                ...Object.keys(prodPackages),
                ...Object.keys(devPackages)
              ]).difference(new Set(ignoredPackages));

              for (const packageName of packageNames) {
                const prodPackage = prodPackages[packageName];
                const devPackage = devPackages[packageName];
                const package = prodPackage ?? devPackage;

                packages[packageName] = {
                  name: packageName,
                  current: package.current,
                  latest: package.latest,
                  dependencyType: package.dependencyType
                };
              }

              return packages;
            };

            const getPackageScope = (package) => {
              switch (package.dependencyType) {
                case 'dependencies':
                  return 'prod';
                case 'devDependencies':
                  return 'dev';
                default:
                  return null;
              }
            };

            const getGroupScope = (group) => {
              const scopes = Object.values(group.packages)
                .map((package) => getPackageScope(package))
                .filter(Boolean);

              if (scopes.includes('prod')) {
                return 'prod';
              }

              if (scopes.includes('dev')) {
                return 'dev';
              }

              return null;
            };

            const groupPackages = (packages, packageGroups) => {
              const groupedPackageNames = new Set();

              const groups = {};
              for (const groupName in packageGroups) {
                const group = {
                  name: groupName,
                  packages: packageGroups[groupName].reduce(
                    (acc, packageName) => {
                      if (packages[packageName]) {
                        acc[packageName] = packages[packageName];
                        groupedPackageNames.add(packageName);
                      }

                      return acc;
                    },
                    {}
                  )
                };

                if (Object.keys(group.packages).length > 0) {
                  groups[groupName] = group;
                }
              }

              const ungroupedPackages = {};
              for (const packageName in packages) {
                if (!groupedPackageNames.has(packageName)) {
                  ungroupedPackages[packageName] = packages[packageName];
                }
              }

              return {
                groups,
                packages: ungroupedPackages,
              };
            };

            const createScopeBranchName = (scope) => scope ? `-${scope}` : '';

            const createGroupBranchName = (group) => {
              const scope = getGroupScope(group);
              const scopeBranchName = createScopeBranchName(scope);

              const date = getCurrentDateString();

              if (group.name === 'all') {
                return `deps${scopeBranchName}-${date}`;
              }

              return `deps${scopeBranchName}-${group.name}-${date}`;
            };

            const createPackageBranchName = (package) => {
              const scope = getPackageScope(package);
              const scopeBranchName = createScopeBranchName(scope);

              return `deps${scopeBranchName}-${package.name}-${package.latest}`;
            };

            const createGroupPullRequestTitle = (group) => {
              const scope = getGroupScope(group);
              const scopeName = scope ? `(${scope})` : '';

              const date = getCurrentDateString();

              if (group.name === 'all') {
                return `deps${scopeName}: Update packages (${date})`;
              }

              return `deps${scopeName}: Update ${group.name} packages (${date})`;
            };

            const createPackagePullRequestTitle = (package) => {
              const scope = getPackageScope(package);
              const scopeName = scope ? `(${scope})` : '';

              return `deps${scopeName}: Update ${package.name} ${package.current} to ${package.latest}`;
            };

            const createScopePullRequestLabel = (scope) =>
              ['type: deps', scope ? `scope: ${scope}` : null]
                .filter(Boolean)
                .join('\n');

            const createGroupPullRequestLabels = (group) => {
              const scope = getGroupScope(group);
              return createScopePullRequestLabel(scope);
            };

            const createPackagePullRequestLabels = (package) => {
              const scope = getPackageScope(package);
              return createScopePullRequestLabel(scope);
            };

            const createPackageTable = (packages) => {
              const tableRows = [
                ['Name', 'Scope', 'Versions'],
                ['---', '---', '---'],
                ...Object.entries(packages).map(([packageName, package]) => [
                  `\`${packageName}\``,
                  getPackageScope(package) ?? 'unknown',
                  `\`${package.current}\` to \`${package.latest}\``
                ])
              ];

              return tableRows.map(row => `| ${row.join(' | ')} |`).join('\n');
            };

            // -----------------------------------------------------------------

            const updateStrategy = core.getInput('update-strategy', { required: true });
            const maxPullRequests = parseInt(core.getInput('max-pull-requests', { required: true }), 10);
            const packageGroups = JSON.parse(core.getInput('package-groups', { required: true }));
            const ignoredPackages = JSON.parse(core.getInput('ignored-packages', { required: true }));
            const outdatedProdPackages = JSON.parse(core.getInput('outdated-prod-packages', { required: true }));
            const outdatedDevPackages = JSON.parse(core.getInput('outdated-dev-packages', { required: true }));

            const outdatedPackages = preparePackages(outdatedProdPackages, outdatedDevPackages, ignoredPackages);
            const updatePackageGroups = updateStrategy === 'Single PR' ? { all: Object.keys(outdatedPackages) } : packageGroups;
            const { groups, packages } = groupPackages(outdatedPackages, updatePackageGroups);

            const groupUpdates = Object.entries(groups).map(([groupName, group]) => ({
              title: createGroupPullRequestTitle(group),
              body: createPackageTable(group.packages),
              branchName: createGroupBranchName(group),
              versionedPackageNames: Object.keys(group.packages).map(packageName => `${packageName}@${group.packages[packageName].latest}`),
              labels: createGroupPullRequestLabels(group),
            }));

            const packageUpdates = Object.entries(packages).map(([packageName, package]) => ({
              title: createPackagePullRequestTitle(package),
              body: createPackageTable({ [packageName]: package }),
              branchName: createPackageBranchName(package),
              versionedPackageNames: [`${packageName}@${package.latest}`],
              labels: createPackagePullRequestLabels(package),
            }));

            const updates = [...groupUpdates, ...packageUpdates].slice(0, maxPullRequests);
            core.setOutput('updates', JSON.stringify(updates));

          update-strategy: ${{ env.INPUT_UPDATE_STRATEGY }}
          max-pull-requests: ${{ env.INPUT_MAX_PULL_REQUESTS }}
          package-groups: ${{ env.INPUT_PACKAGE_GROUPS }}
          ignored-packages: ${{ env.INPUT_IGNORED_PACKAGES }}
          outdated-prod-packages: ${{ steps.get-outdated-packages.outputs.outdated-prod-packages }}
          outdated-dev-packages: ${{ steps.get-outdated-packages.outputs.outdated-dev-packages }}

  create-pull-requests:
    name: Create pull request
    runs-on: ubuntu-latest
    needs: prepare-updates
    if: needs.prepare-updates.outputs.updates != '[]'
    strategy:
      fail-fast: false
      matrix:
        update: ${{ fromJson(needs.prepare-updates.outputs.updates) }}

    steps:
      - name: Get bot token (main)
        id: get-bot-token-main
        if: env.INPUT_EXTERNAL_CALL == 'false' && env.SECRET_TOKEN == ''
        uses: cluerise/actions/get-github-app-token@main
        with:
          app-id: ${{ env.INPUT_APP_ID }}
          app-private-key: ${{ env.SECRET_APP_PRIVATE_KEY }}

      - name: Get bot token (version)
        id: get-bot-token-version
        if: env.INPUT_EXTERNAL_CALL == 'true' && env.SECRET_TOKEN == ''
        uses: cluerise/actions/get-github-app-token@v7.0.4
        with:
          app-id: ${{ env.INPUT_APP_ID }}
          app-private-key: ${{ env.SECRET_APP_PRIVATE_KEY }}

      - name: Set bot token
        run: echo "BOT_TOKEN=${{ steps.get-bot-token-main.outputs.token || steps.get-bot-token-version.outputs.token }}" >> $GITHUB_ENV

      - name: Install (main)
        if: env.INPUT_EXTERNAL_CALL == 'false'
        uses: cluerise/actions/install@main

      - name: Install (version)
        if: env.INPUT_EXTERNAL_CALL == 'true'
        uses: cluerise/actions/install@v7.0.4

      - name: Update packages
        run: pnpm update --recursive ${{ join(matrix.update.versionedPackageNames, ' ') }}

      - name: Create a pull request with the updated files
        uses: branoholy/update-files-action@main
        with:
          token: ${{ env.SECRET_TOKEN || env.BOT_TOKEN }}
          branch.name: ${{ matrix.update.branchName }}
          branch.recreate: true
          commit.paths: |
            **/package.json
            pnpm-lock.yaml
          commit.message: ${{ matrix.update.title }}
          commit.token: ${{ env.BOT_TOKEN }}
          pull-request.body: ${{ matrix.update.body }}
          pull-request.labels: ${{ matrix.update.labels }}
